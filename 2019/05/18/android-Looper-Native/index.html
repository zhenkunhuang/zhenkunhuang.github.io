<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="一、Looper(Native)序言&amp;#8195;&amp;#8195;学习此篇前,请确认掌握了eventfd以及epoll的使用 简介&amp;#8195;&amp;#8195;在Android P源码分析之Handler(JAVA)篇中,我们分析了Java层的消息循环处理流程,其中Looper扮演着不断从消息队列中取出消息进行分发处理的重要角色.而在Native层中,也存在着相同作用的Looper. 示例类定义123">
<meta property="og:type" content="article">
<meta property="og:title" content="Android P源码分析之Looper(Native)">
<meta property="og:url" content="http://yoursite.com/2019/05/18/android-Looper-Native/index.html">
<meta property="og:site_name">
<meta property="og:description" content="一、Looper(Native)序言&amp;#8195;&amp;#8195;学习此篇前,请确认掌握了eventfd以及epoll的使用 简介&amp;#8195;&amp;#8195;在Android P源码分析之Handler(JAVA)篇中,我们分析了Java层的消息循环处理流程,其中Looper扮演着不断从消息队列中取出消息进行分发处理的重要角色.而在Native层中,也存在着相同作用的Looper. 示例类定义123">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/05/18/android-Looper-Native/Looper_UML.png">
<meta property="og:image" content="http://yoursite.com/2019/05/18/android-Looper-Native/Looper_native.png">
<meta property="og:image" content="http://yoursite.com/2019/05/18/android-Looper-Native/Looper.png">
<meta property="og:updated_time" content="2019-05-19T08:59:07.342Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android P源码分析之Looper(Native)">
<meta name="twitter:description" content="一、Looper(Native)序言&amp;#8195;&amp;#8195;学习此篇前,请确认掌握了eventfd以及epoll的使用 简介&amp;#8195;&amp;#8195;在Android P源码分析之Handler(JAVA)篇中,我们分析了Java层的消息循环处理流程,其中Looper扮演着不断从消息队列中取出消息进行分发处理的重要角色.而在Native层中,也存在着相同作用的Looper. 示例类定义123">
<meta name="twitter:image" content="http://yoursite.com/2019/05/18/android-Looper-Native/Looper_UML.png">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/05/18/android-Looper-Native/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Android P源码分析之Looper(Native) | </title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title"></span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/18/android-Looper-Native/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sky.Huang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android P源码分析之Looper(Native)

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-18 20:15:08" itemprop="dateCreated datePublished" datetime="2019-05-18T20:15:08+08:00">2019-05-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-19 16:59:07" itemprop="dateModified" datetime="2019-05-19T16:59:07+08:00">2019-05-19</time>
              
            
          </span>

          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/18/android-Looper-Native/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/18/android-Looper-Native/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="一、Looper-Native"><a href="#一、Looper-Native" class="headerlink" title="一、Looper(Native)"></a>一、Looper(Native)</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>&#8195;&#8195;<strong>学习此篇前,请确认掌握了<a href="/2019/04/20/linux-eventfd/" title="eventfd">eventfd</a>以及<a href="/2019/04/23/linux-epoll/" title="epoll">epoll</a>的使用</strong></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&#8195;&#8195;在<a href="/2019/05/05/android-handler-java/" title="Android P源码分析之Handler(JAVA)篇">Android P源码分析之Handler(JAVA)篇</a>中,我们分析了<font color="#ff0000">Java层</font>的消息循环处理流程,其中Looper扮演着不断从消息队列中取出消息进行分发处理的重要角色.而在<font color="#ff0000">Native层</font>中,也存在着相同作用的Looper.</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>类定义</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalHandler</span> :</span> <span class="keyword">public</span> MessageHandler, <span class="keyword">public</span> LooperCallback&#123;</span><br><span class="line"><span class="comment">/* MessageHandler为消息事务处理类, LooperCallback为Fd事务处理类 */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">const</span> Message&amp; message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 消息事务处理函数,在消费者线程consumerThread中执行 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"tid : %d, receive message : %d\n"</span>, gettid(), message.what);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">handleEvent</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data __unused)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* Fd事务处理函数,在消费者线程consumerThread中执行 */</span></span><br><span class="line">        <span class="keyword">char</span> recvMsg[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (events &amp; Looper::EVENT_INPUT) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (read(fd, recvMsg, <span class="keyword">sizeof</span>(recvMsg) / <span class="keyword">sizeof</span>(*recvMsg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        		<span class="built_in">printf</span>(<span class="string">"tid : %d, read fail, reason : %s\n"</span>,gettid(), strerror(errno));</span><br><span class="line">        		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">"tid : %d, receive event : %s\n"</span>,gettid(), recvMsg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>消费者线程执行体</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumerThread_func</span><span class="params">(<span class="keyword">void</span> *arg __unused)</span> </span>&#123;  </span><br><span class="line">	looper = Looper::prepare(<span class="number">0</span>); <span class="comment">/* 创建线程唯一的Looper对象并绑定到消费者线程,见1.1 */</span></span><br><span class="line"></span><br><span class="line">	sem_post(&amp;sem); <span class="comment">/* 通知生产者线程producerThread Looper就绪 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (consumeThreadExit == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 循环处理Looper事务,见1.4 */</span></span><br><span class="line">		looper -&gt; pollOnce(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>生产者线程执行体</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producerThread_func</span><span class="params">(<span class="keyword">void</span> *arg __unused)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> msg[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">/* 创建事务处理者handler */</span></span><br><span class="line">    sp&lt;LocalHandler&gt; handler = <span class="keyword">new</span> LocalHandler();</span><br><span class="line">    <span class="comment">/* 创建pipe,其中fd[0]为读取端,fd[1]为写入端 */</span></span><br><span class="line">    pipe(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待消费者线程初始化Looper */</span></span><br><span class="line">    sem_wait(&amp;sem);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"tid : %d sem_wait looper prepare success\n"</span>,gettid());</span><br><span class="line">    <span class="comment">/* 发送消息事务Message,唤醒消费者线程consumerThread处理消息事务 */</span></span><br><span class="line">    looper -&gt; sendMessage(handler, Message());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加Fd事务请求:Fd为pipe读取端fd[0],事务类型为事件可读 */</span></span><br><span class="line">    looper -&gt; addFd(fd[<span class="number">0</span>], <span class="number">0</span>, Looper::EVENT_INPUT, handler, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 从终端读取字符串,并写到pipe的写入端fd[1] </span></span><br><span class="line"><span class="comment">     * 此时pipe的poll状态变为可读,从而唤醒消费者线程consumerThread处理Fd事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fgets(msg, <span class="keyword">sizeof</span>(msg) / <span class="keyword">sizeof</span>(*msg), <span class="built_in">stdin</span>);</span><br><span class="line">    write(fd[<span class="number">1</span>], msg, <span class="built_in">strlen</span>(msg) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    close(fd[<span class="number">0</span>]);</span><br><span class="line">    close(fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>运行结果</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tid : 8234 sem_wait looper prepare success /* 生产者线程 */</span><br><span class="line">tid : 8235, receive message : 0            /* 消费者线程处理消息事务 */</span><br><span class="line">Hello World     &lt;---终端输入</span><br><span class="line">tid : 8235, receive event : Hello World    /* 消费者线程处理Fd事务 */</span><br></pre></td></tr></table></figure></p>
<p>&#8195;&#8195;<font color="#ff0000"><strong>接下来我们将从消费者线程和生产者线程角度分析示例流程</strong></font></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="消费者线程"><a href="#消费者线程" class="headerlink" title="消费者线程"></a>消费者线程</h3><p>&#8195;&#8195;<strong>我们首先分析Looper(Native)的初始化函数prepare</strong></p>
<h4 id="1-1-prepare"><a href="#1-1-prepare" class="headerlink" title="1.1 prepare"></a>1.1 prepare</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;Looper&gt; Looper::prepare(<span class="keyword">int</span> opts) &#123;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* 获取当前消费者线程线程绑定的Looper对象</span></span><br><span class="line"><span class="comment">     * 由于这里首次调用prepare,还未绑定Looper,因此返回空 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sp&lt;Looper&gt; looper = Looper::getForThread();</span><br><span class="line">    <span class="keyword">if</span> (looper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* 创建Looper对象(见1.2),然后绑定到当前消费者线程中 */</span></span><br><span class="line">        looper = <span class="keyword">new</span> Looper(allowNonCallbacks);</span><br><span class="line">        Looper::setForThread(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> looper;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-Looper构造函数"><a href="#1-2-Looper构造函数" class="headerlink" title="1.2 Looper构造函数"></a>1.2 Looper构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Looper::Looper(<span class="keyword">bool</span> allowNonCallbacks) &#123;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* 创建eventfd文件描述符mWakeEventFd,用于唤醒处于epoll_wait休眠状态下的消费者线程 */</span></span><br><span class="line">    mWakeEventFd = eventfd(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    <span class="comment">/* 见1.3 */</span></span><br><span class="line">    rebuildEpollLocked();</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-rebuildEpollLocked"><a href="#1-3-rebuildEpollLocked" class="headerlink" title="1.3 rebuildEpollLocked"></a>1.3 rebuildEpollLocked</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::rebuildEpollLocked() &#123;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* 创建epoll文件描述符,用于监听多路IO状态 */</span></span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* epoll添加mWakeEventFd监听(可读) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event)); </span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    eventItem.data.fd = mWakeEventFd;</span><br><span class="line">    <span class="keyword">int</span> result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong><br>&#8195;&#8195;<strong>1.创建Looper对象并绑定到<font color="#ff0000">消费者线程</font></strong><br>&#8195;&#8195;<strong>2.创建eventfd文件描述符mWakeEventFd</strong><br>&#8195;&#8195;<strong>3.创建epoll文件描述符mEpollFd,并将mWakeEventFd添加到监听Fd事项中</strong></p>
<p><strong>接下来分析Looper(Native)事务处理函数pollOnce</strong></p>
<h4 id="1-4-pollOnce"><a href="#1-4-pollOnce" class="headerlink" title="1.4 pollOnce"></a>1.4 pollOnce</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Looper::pollOnce(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData) &#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	<span class="comment">/* 当result不为0时,返回 */</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 见1.5 */</span></span><br><span class="line">        result = pollInner(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-5-pollInner"><a href="#1-5-pollInner" class="headerlink" title="1.5 pollInner"></a>1.5 pollInner</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Looper::pollInner(<span class="keyword">int</span> timeoutMillis) &#123;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* 校准epoll超时时间,取timeoutMillis和(mNextMessageUptime - now)之间大于0且较小的那个 */</span></span><br><span class="line">    <span class="keyword">if</span> (timeoutMillis != <span class="number">0</span> &amp;&amp; mNextMessageUptime != LLONG_MAX) &#123;</span><br><span class="line">        <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        <span class="keyword">int</span> messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);</span><br><span class="line">        <span class="keyword">if</span> (messageTimeoutMillis &gt;= <span class="number">0</span></span><br><span class="line">                &amp;&amp; (timeoutMillis &lt; <span class="number">0</span> || messageTimeoutMillis &lt; timeoutMillis)) &#123;</span><br><span class="line">            timeoutMillis = messageTimeoutMillis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = POLL_WAKE;</span><br><span class="line">    <span class="comment">/* 清除Fd就绪事务队列 */</span></span><br><span class="line">    mResponses.clear();</span><br><span class="line">    mResponseIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="comment">/* 消费者线程调用epol_wait超时休眠,等待监听的Fd事项就绪 */</span></span><br><span class="line">    <span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是超时唤醒,则直接跳过就绪Fd事项数组遍历 */</span></span><br><span class="line">    <span class="keyword">if</span> (eventCount == <span class="number">0</span>) &#123;</span><br><span class="line">        result = POLL_TIMEOUT;</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 遍历就绪Fd事项数组eventItems */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">        <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeEventFd) &#123;</span><br><span class="line">        <span class="comment">/* 当mWakeEventFd在就绪Fd事项数组中,需调用awoken函数读取mWakeEventFd的内容,</span></span><br><span class="line"><span class="comment">         * 防止下次调用epoll_wait时,mWakeEventFd的poll状态仍为可读导致直接返回(epoll水平触发特性) </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                awoken();</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 以文件描述符fd为索引值取出对应的事务请求Request,用于构建Fd就绪事务Response对象,</span></span><br><span class="line"><span class="comment">         * 然后将Response入队到Fd就绪事务队列mResponses中等待处理 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">            <span class="keyword">if</span> (requestIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> events = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</span><br><span class="line">                pushResponse(events, mRequests.valueAt(requestIndex));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Done: ;</span><br><span class="line">    <span class="comment">/* 遍历消息事务队列mMessageEnvelopes */</span></span><br><span class="line">    <span class="keyword">while</span> (mMessageEnvelopes.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        <span class="keyword">const</span> MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (messageEnvelope.uptime &lt;= now) &#123;</span><br><span class="line">        <span class="comment">/* 当前时间 &gt; 消息事务messageEnvelope分发时间,</span></span><br><span class="line"><span class="comment">         * 消息事务messageEnvelope出队并执行事务处理(handleMessage)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            &#123; </span><br><span class="line">                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</span><br><span class="line">                Message message = messageEnvelope.message;</span><br><span class="line">                mMessageEnvelopes.removeAt(<span class="number">0</span>);</span><br><span class="line">                handler-&gt;handleMessage(message);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 未到消息事务分发时间,</span></span><br><span class="line"><span class="comment">         * 设置mNextMessageUptime为消息事务分发时间uptime,并跳出遍历 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            mNextMessageUptime = messageEnvelope.uptime;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 遍历Fd就绪事务队列mResponses */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mResponses.size(); i++) &#123;</span><br><span class="line">        Response&amp; response = mResponses.editItemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class="line">        <span class="comment">/* Fd事务请求的标识ident为POLL_CALLBACK,</span></span><br><span class="line"><span class="comment">         * 处理Fd就绪事务response(handleEvent)</span></span><br><span class="line"><span class="comment">         * Fd事务处理函数handleEvent返回值为0时,epoll将移除对Fd事务请求request的监听</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            <span class="keyword">int</span> fd = response.request.fd;</span><br><span class="line">            <span class="keyword">int</span> events = response.events;</span><br><span class="line">            <span class="keyword">void</span>* data = response.request.data;</span><br><span class="line">            <span class="keyword">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br><span class="line">            <span class="keyword">if</span> (callbackResult == <span class="number">0</span>) &#123;</span><br><span class="line">                removeFd(fd, response.request.seq);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong><br>&#8195;&#8195;<strong>1.<font color="#ff0000">消费者线程</font>调用epoll_wait检测是否有事务就绪,如果无事务就绪则会进入休眠,等待事务就绪时唤醒</strong><br>&#8195;&#8195;<strong>2.当Fd事项就绪时,<font color="#ff0000">消费者线程</font>被唤醒.先处理消息事务MessageEnvelope(handleMessage),最后处理Fd就绪事务Response(handleEvent,返回值为0时epoll将移除对Fd事务请求request的监听)</strong></p>
<h3 id="生产者线程"><a href="#生产者线程" class="headerlink" title="生产者线程"></a>生产者线程</h3><p>&#8195;&#8195;<strong>我们首先分析下发送消息事务sendMessage</strong></p>
<h4 id="2-1-sendMessage"><a href="#2-1-sendMessage" class="headerlink" title="2.1 sendMessage"></a>2.1 sendMessage</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::sendMessage(<span class="keyword">const</span> sp&lt;MessageHandler&gt;&amp; handler, <span class="keyword">const</span> Message&amp; message) &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">    <span class="comment">/* 见2.2 */</span></span><br><span class="line">    sendMessageAtTime(now, handler, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-sendMessageAtTime"><a href="#2-2-sendMessageAtTime" class="headerlink" title="2.2 sendMessageAtTime"></a>2.2 sendMessageAtTime</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::sendMessageAtTime(<span class="keyword">nsecs_t</span> uptime, <span class="keyword">const</span> sp&lt;MessageHandler&gt;&amp; handler,</span><br><span class="line">        <span class="keyword">const</span> Message&amp; message) &#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* 构建消息事务MessageEnvelope并入队到消息事务队列mMessageEnvelopes中(分发时间uptime升序排序) */</span></span><br><span class="line">    <span class="keyword">size_t</span> messageCount = mMessageEnvelopes.size();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) &#123;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">MessageEnvelope <span class="title">messageEnvelope</span><span class="params">(uptime, handler, message)</span></span>;</span><br><span class="line">    mMessageEnvelopes.insertAt(messageEnvelope, i, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果入队的位置为头部,则立即唤醒消费者线程进行处理 */</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        wake(); <span class="comment">/* 见2.3 */</span></span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-wake"><a href="#2-3-wake" class="headerlink" title="2.3 wake"></a>2.3 wake</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::wake() &#123;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* 当对mWakeEventFd写入内容时, mWakeEventFd的poll状态变为可读就绪状态</span></span><br><span class="line"><span class="comment">     * 由于epoll监听mWakeEventFd,因此当mWakeEventFd就绪时,消费者线程会从epoll_wait的休眠中被唤醒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> inc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)));</span><br><span class="line">    <span class="keyword">if</span> (nWrite != <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"Could not write wake signal to fd %d: %s"</span>,</span><br><span class="line">                    mWakeEventFd, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong><br>&#8195;&#8195;<strong>1.<font color="#ff0000">生产者线程</font>构建消息事务messageEnvelope,并入队到<font color="#ff0000">消费者线程</font>的消息事务队列mMessageEnvelopes中(分发时间uptime升序排序)</strong><br>&#8195;&#8195;<strong>2.如果入队位置为头节点,则调用wake唤醒<font color="#ff0000">消费者线程</font>处理事务</strong></p>
<p><strong>接下来分析添加Fd事务请求addfd</strong></p>
<h4 id="2-4-addfd"><a href="#2-4-addfd" class="headerlink" title="2.4 addfd"></a>2.4 addfd</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Looper::addFd(<span class="keyword">int</span> fd, <span class="keyword">int</span> ident, <span class="keyword">int</span> events, <span class="keyword">const</span> sp&lt;LooperCallback&gt;&amp; callback, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构建Fd事务请求request */</span></span><br><span class="line">    Request request;</span><br><span class="line">    request.fd = fd;</span><br><span class="line">    request.ident = ident;</span><br><span class="line">    request.events = events;</span><br><span class="line">    request.seq = mNextRequestSeq++;</span><br><span class="line">    request.callback = callback;</span><br><span class="line">    request.data = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">    <span class="keyword">if</span> (requestIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* 首次添加Fd事务请求</span></span><br><span class="line"><span class="comment">     * 1.epoll添加该fd监听</span></span><br><span class="line"><span class="comment">     * 2.将request加入到Fd事务请求队列mRequests中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem);</span><br><span class="line">        mRequests.add(fd, request);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 非首次添加Fd事务请求</span></span><br><span class="line"><span class="comment">     * 1. epoll更新该fd监听事项</span></span><br><span class="line"><span class="comment">     * 2. 更新Fd事务请求request</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp; eventItem);</span><br><span class="line">        mRequests.replaceValueAt(requestIndex, request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong><br>&#8195;&#8195;<strong>1.<font color="#ff0000">生产者线程</font>构建Fd事务请求request,并入队到<font color="#ff0000">消费者线程</font>的Fd事务请求队列mRequests中</strong><br>&#8195;&#8195;<strong>2.<font color="#ff0000">消费者线程</font>mEpollFd添加fd事项监听</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><div align="center"><img src="/2019/05/18/android-Looper-Native/Looper_UML.png" alt="Looper_UML"></div></p>
<p><div align="center"><img src="/2019/05/18/android-Looper-Native/Looper_native.png" alt="Looper_native"></div></p>
<p>&#8195;&#8195;<strong>1.<font color="#ff0000">消费者线程</font>创建Looper(Native),并调用pollOnce处理事务,当无事务处理时,epoll_wait会让<font color="#ff0000">消费者线程</font>进入休眠状态</strong><br>&#8195;&#8195;<strong>2.<font color="#ff0000">生产者线程</font>传入事务到<font color="#ff0000">消费者线程</font>的事务队列中,并唤醒<font color="#ff0000">消费者线程</font>进行处理</strong></p>
<h1 id="二、MessageQueue"><a href="#二、MessageQueue" class="headerlink" title="二、MessageQueue"></a>二、MessageQueue</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>&#8195;&#8195;在<a href="/2019/05/05/android-handler-java/" title="Android P源码分析之Handler(JAVA)篇">Android P源码分析之Handler(JAVA)篇</a>中,我们分析了MessageQueue类的取出消息next流程以及入队消息enqueueMessage流程<br>&#8195;&#8195;以上两个流程中,都有调用Native方法(nativePollOnce和nativeWake),接下来我们将对这两个Native方法进行分析</p>
<h2 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h2><p>&#8195;&#8195;<strong>我们首先分析MessageQueue的构造函数</strong></p>
<h3 id="3-1-MessageQueue构造函数"><a href="#3-1-MessageQueue构造函数" class="headerlink" title="3.1 MessageQueue构造函数"></a>3.1 MessageQueue构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    <span class="comment">/* Native函数,构建NativeMessageQueue对象并返回对象地址,见3.2 */</span></span><br><span class="line">    mPtr = nativeInit(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-nativeInit"><a href="#3-2-nativeInit" class="headerlink" title="3.2 nativeInit"></a>3.2 nativeInit</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* 构建NativeMessageQueue对象,构造函数见3.3 */</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回nativeMessageQueue对象地址 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-NativeMessageQueue构造函数"><a href="#3-3-NativeMessageQueue构造函数" class="headerlink" title="3.3 NativeMessageQueue构造函数"></a>3.3 NativeMessageQueue构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NativeMessageQueue::NativeMessageQueue() &#123;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* 获取当前消费者线程线程绑定的Looper对象</span></span><br><span class="line"><span class="comment">     * 由于这里首次构建NativeMessageQueue,还未绑定Looper,因此返回空 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mLooper = Looper::getForThread();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* 构建Looper(Native)对象并绑定到消费者线程,构造函数见1.2 */</span></span><br><span class="line">        mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</span><br><span class="line">        Looper::setForThread(mLooper);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong><br>&#8195;&#8195;<strong>1.MessageQueue(<font color="#ff0000">Java</font>)构建了NativeMessageQueue(<font color="#ff0000">Native</font>)对象,并记录该对象地址</strong><br>&#8195;&#8195;<strong>2.NativeMessageQueue(<font color="#ff0000">Native</font>)构建Looper(<font color="#ff0000">Native</font>)对象,并绑定到消费者线程</strong></p>
<p><strong>接下来分析MessageQueue取出消息next函数中使用的nativePollOnce方法</strong></p>
<h3 id="3-4-next"><a href="#3-4-next" class="headerlink" title="3.4 next"></a>3.4 next</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* native方法,处理Looper(Native)事务</span></span><br><span class="line"><span class="comment">     * 如无事务处理则会让消费者线程进入超时休眠状态,nextPollTimeoutMillis为超时时间,见3.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);	</span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* 以下为取消息Message流程,这里不再重复贴出 */</span></span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-nativePollOnce"><a href="#3-5-nativePollOnce" class="headerlink" title="3.5 nativePollOnce"></a>3.5 nativePollOnce</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 指针转换,得到从nativeInit构建的NativeMessageQueue对象 */</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    <span class="comment">/* 最终调用的是消费者线程Looper(Native)的pollOnce进行事务处理,见1.4 */</span></span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong><br>&#8195;&#8195;<strong>1.Looper(<font color="#ff0000">Java</font>)启动消息循环,先处理Looper(<font color="#ff0000">Native</font>)事务,然后再处理Looper(<font color="#ff0000">Java</font>)事务</strong><br>&#8195;&#8195;<strong>2.Looper(<font color="#ff0000">Native</font>)和Looper(<font color="#ff0000">Java</font>)均无事务处理时,<font color="#ff0000">消费者线程</font>会进入超时休眠状态,等待事务就绪时唤醒</strong></p>
<p><strong>最后分析入队消息enqueueMessage函数中使用的nativeWake方法</strong></p>
<h3 id="3-6-enqueueMessage"><a href="#3-6-enqueueMessage" class="headerlink" title="3.6 enqueueMessage"></a>3.6 enqueueMessage</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* 以上为消息事务Message入队列流程,这里不再重复贴出 */</span></span><br><span class="line">    <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">        <span class="comment">/* native方法,唤醒消费者线程,见3.7 */</span></span><br><span class="line">        nativeWake(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-7-nativeWake"><a href="#3-7-nativeWake" class="headerlink" title="3.7 nativeWake"></a>3.7 nativeWake</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 指针转换,得到从nativeInit构建的NativeMessageQueue对象 */</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    <span class="comment">/* 唤醒处于epoll_wait休眠状态下的消费者线程,见2.3 */</span></span><br><span class="line">    nativeMessageQueue-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong><br>&#8195;&#8195;<strong><font color="#ff0000">生产者线程</font>将消息事务Message(<font color="#ff0000">Java</font>)入队到<font color="#ff0000">消费者线程</font>的消息队列MessageQueue(<font color="#ff0000">Java</font>)中,如果符合唤醒条件则会调用Native方法nativeWake唤醒<font color="#ff0000">消费者线程</font></strong></p>
<h1 id="三、全文总结"><a href="#三、全文总结" class="headerlink" title="三、全文总结"></a>三、全文总结</h1><p><div align="center"><img src="/2019/05/18/android-Looper-Native/Looper.png" alt="Looper"></div></p>
<p align="center"><strong>本章完</strong></p>
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/11/android-RefBase-sp-wp/" rel="next" title="Android P源码分析之RefBase & sp,wp">
                <i class="fa fa-chevron-left"></i> Android P源码分析之RefBase & sp,wp
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sky.Huang</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、Looper-Native"><span class="nav-number">1.</span> <span class="nav-text">一、Looper(Native)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#序言"><span class="nav-number">1.1.</span> <span class="nav-text">序言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">1.2.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例"><span class="nav-number">1.3.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码分析"><span class="nav-number">1.4.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#消费者线程"><span class="nav-number">1.4.1.</span> <span class="nav-text">消费者线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-prepare"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">1.1 prepare</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-Looper构造函数"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">1.2 Looper构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-rebuildEpollLocked"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">1.3 rebuildEpollLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-pollOnce"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">1.4 pollOnce</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-pollInner"><span class="nav-number">1.4.1.5.</span> <span class="nav-text">1.5 pollInner</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生产者线程"><span class="nav-number">1.4.2.</span> <span class="nav-text">生产者线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-sendMessage"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">2.1 sendMessage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-sendMessageAtTime"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">2.2 sendMessageAtTime</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-wake"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">2.3 wake</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-addfd"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">2.4 addfd</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、MessageQueue"><span class="nav-number">2.</span> <span class="nav-text">二、MessageQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介-1"><span class="nav-number">2.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码分析-1"><span class="nav-number">2.2.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-MessageQueue构造函数"><span class="nav-number">2.2.1.</span> <span class="nav-text">3.1 MessageQueue构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-nativeInit"><span class="nav-number">2.2.2.</span> <span class="nav-text">3.2 nativeInit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-NativeMessageQueue构造函数"><span class="nav-number">2.2.3.</span> <span class="nav-text">3.3 NativeMessageQueue构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-next"><span class="nav-number">2.2.4.</span> <span class="nav-text">3.4 next</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-nativePollOnce"><span class="nav-number">2.2.5.</span> <span class="nav-text">3.5 nativePollOnce</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-enqueueMessage"><span class="nav-number">2.2.6.</span> <span class="nav-text">3.6 enqueueMessage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-nativeWake"><span class="nav-number">2.2.7.</span> <span class="nav-text">3.7 nativeWake</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、全文总结"><span class="nav-number">3.</span> <span class="nav-text">三、全文总结</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sky.Huang</span>

  

  
</div>










    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span>

        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>




  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: '1O6SFHo5IjuhnJWOW6TvJ9uw-gzGzoHsz',
    appKey: 'eWE8uHVODVHqjJkkWoqENJty',
    placeholder: 'Leave a comment',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn'
  });
</script>




  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
